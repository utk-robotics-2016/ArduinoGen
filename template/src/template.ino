// Auto-generated by ArduinoGen

// Includes
#include "CmdMessenger.h"
#include <Wire.h>
#include "I2CEncoder.h"
#include "Servo.h"
#include "Motor.h"
#include "Stepper.h"
#include "Encoder.h"
#include "NewPing.h"
#include "PID.h"
#include "vPID.h"
#include "VelocityControlledMotor.h"
#include "Arm.h"
#include "FourWheelDrive.h"

// Globals
int ledState = HIGH;

// Pin definitions
const char LED = 13;

const char template_button0_pin = 10;
const char template_button1_pin = 15;
const char template_button2_pin = 15;
const char template_button3_pin = 14;
const char template_limit_switch0_pin = 9;
const char template_limit_switch1_pin = 5;
const char template_limit_switch2_pin = 10;
const char template_limit_switch3_pin = 14;
const char template_switch0_pin = 4;
const char template_switch1_pin = 2;
const char template_switch2_pin = 5;
const char template_switch3_pin = 14;

const char template_servo_pin = 5;

const char template_monster_moto_motor0_Apin = 9;
const char template_monster_moto_motor0_Bpin = 13;
const char template_monster_moto_motor0_PWMpin = 5;
const char template_monster_moto_motor1_Apin = 12;
const char template_monster_moto_motor1_Bpin = 16;
const char template_monster_moto_motor1_PWMpin = 10;
const char template_rover_five_motor0_Apin = 10;
const char template_rover_five_motor0_Bpin = -1;
const char template_rover_five_motor0_PWMpin = 8;
const char template_rover_five_motor1_Apin = 11;
const char template_rover_five_motor1_Bpin = -1;
const char template_rover_five_motor1_PWMpin = 15;
const char template_stepper_pinA = 16;
const char template_stepper_pinB = 14;
const char template_stepper_pinC = 6;
const char template_stepper_pinD = 9;

const char template_encoder0_pinA = 4;
const char template_encoder0_pinB = 8;
const char template_encoder1_pinA = 16;
const char template_encoder1_pinB = 6;

const char template_line_sensor1_pin = 13;
const char template_line_sensor0_pin = 4;

const char template_ultrasonic_pin = 8;


// Constructors
// Attach a new CmdMessenger object to the default Serial port
CmdMessenger cmdMessenger = CmdMessenger(Serial);

// This is the list of recognized commands. These can be commands that can either be sent or received.
// In order to receive, attach a callback function to these events
enum {
	kAcknowledge,
	kStart,
	kResult,
	kError,
	kUnknown,
	kSetLed,
	kI2CEncoderPosition,
	kI2CEncoderRawPosition,
	kI2CEncoderSpeed,
	kI2CEncoderVelocity,
	kI2CEncoderZero,
	kReadSwitch,
	kSetServo,
	kDetachServo,
	kDriveMotor,
	kStopMotor,
	kSetStepperSpeed,
	kStepStepper,
	kSetVCMVoltage,
	kSetVCMVelocity,
	kStopVCM,
	kGetVCMVelocity,
	kGetVCMPosition,
	kSetArm,
	kDetachArm,
	kDriveFWD,
	kStopFWD,
	kDriveFWD_PID,
	kGetFWDLeftVelocity,
	kGetFWDRightVelocity,
	kGetFWDLeftPosition,
	kGetFWDRightPosition,
	kReadEncoder,
	kZeroEncoder,
	kReadDigitalLineSensor,
	kReadAnalogLineSensor,
	kReadUltrasonic,
	kModifyPidConstants,
	kSetPidSetpoint,
	kPidOff,
	kPidDisplay,
	kModifyVpidConstants,
	kSetVpidSetpoint,
	kVpidOff,
	kVpidDisplay
};
const char template_i2c_encoder1_index = 0;
const char template_i2c_encoder0_index = 1;
I2CEncoder i2cencoders[2];

const char template_button0_index = 0;
const char template_button1_index = 1;
const char template_button2_index = 2;
const char template_button3_index = 3;
const char template_limit_switch0_index = 4;
const char template_limit_switch1_index = 5;
const char template_limit_switch2_index = 6;
const char template_limit_switch3_index = 7;
const char template_switch0_index = 8;
const char template_switch1_index = 9;
const char template_switch2_index = 10;
const char template_switch3_index = 11;
char switches[12] = {
	template_button0_pin,
	template_button1_pin,
	template_button2_pin,
	template_button3_pin,
	template_limit_switch0_pin,
	template_limit_switch1_pin,
	template_limit_switch2_pin,
	template_limit_switch3_pin,
	template_switch0_pin,
	template_switch1_pin,
	template_switch2_pin,
	template_switch3_pin
};

const char template_servo_index = 0;
char servo_pins[1] = {
	template_servo_pin
};
Servo servos[1];

const char template_monster_moto_motor0_index = 0;
const char template_monster_moto_motor1_index = 1;
const char template_rover_five_motor0_index = 2;
const char template_rover_five_motor1_index = 3;
Motor motors[4] = {
	Motor(template_monster_moto_motor0_Apin, template_monster_moto_motor0_Bpin, template_monster_moto_motor0_PWMpin, 0, MonsterMoto),
	Motor(template_monster_moto_motor1_Apin, template_monster_moto_motor1_Bpin, template_monster_moto_motor1_PWMpin, 1, MonsterMoto),
	Motor(template_rover_five_motor0_Apin, template_rover_five_motor0_Bpin, template_rover_five_motor0_PWMpin, 0, RoverFive),
	Motor(template_rover_five_motor1_Apin, template_rover_five_motor1_Bpin, template_rover_five_motor1_PWMpin, 1, RoverFive)
};

const char template_stepper_index = 0;
Stepper steppers[1] = {
	Stepper(3, template_stepper_pinA, template_stepper_pinB, template_stepper_pinC, template_stepper_pinD)
};

const char template_encoder0_index = 0;
const char template_encoder1_index = 1;
Encoder encoders[2] = {
	Encoder(template_encoder0_pinA, template_encoder0_pinB),
	Encoder(template_encoder1_pinA, template_encoder1_pinB)
};

const char template_line_sensor1_index = 0;
char digital_linesensors[1] = {
	template_line_sensor1_pin
};
const char template_line_sensor0_index = 0;
char analog_linesensors[1] = {
	template_line_sensor0_pin
};

const char template_ultrasonic_index = 0;
NewPing ultrasonics[1] = {
	NewPing(template_ultrasonic_pin, template_ultrasonic_pin)
};

const char template_pid0_index = 0;
const char template_pid3_index = 1;
double lastPositions_vpid[2];
double Inputs_vpid[2], Setpoints_vpid[2], Outputs_vpid[2];
vPID vpids[2] = {
	vPID(&Inputs_vpid[template_pid0_index], &Outputs_vpid[template_pid0_index], &Setpoints_vpid[template_pid0_index], 4.100000, 0.200000, 2.100000, DIRECT),
	vPID(&Inputs_vpid[template_pid3_index], &Outputs_vpid[template_pid3_index], &Setpoints_vpid[template_pid3_index], 4.100000, 0.200000, 2.100000, DIRECT)
};
const char template_pid1_index = 0;
const char template_pid2_index = 1;
double lastPositions_pid[2];
double Inputs_pid[2], Setpoints_pid[2], Outputs_pid[2];
PID pids[2] = {
	PID(&Inputs_pid[template_pid1_index], &Outputs_pid[template_pid1_index], &Setpoints_pid[template_pid1_index], 4.100000, 0.200000, 2.100000, REVERSE),
	PID(&Inputs_pid[template_pid2_index], &Outputs_pid[template_pid2_index], &Setpoints_pid[template_pid2_index], 4.100000, 0.200000, 2.100000, REVERSE)
};

const char template_velocity_controlled_motor_index = 0;
VelocityControlledMotor vcms[1] = {
	VelocityControlledMotor(motors[template_rover_five_motor0_index], i2cencoders[template_i2c_encoder0_index], vpids[template_pid0_index], &Inputs_vpid[template_pid0_index], &Setpoints_vpid[template_pid0_index], &Outputs_vpid[template_pid0_index])
};

Arm arms[1] = {
	Arm(template_servo_index, template_servo_index, template_servo_index, template_servo_index, template_servo_index, servo_pins, servos)
};

FourWheelDrive fwds[] = {
	FourWheelDrive(&motors[template_monster_moto_motor0_index], &motors[template_monster_moto_motor0_index], &motors[template_monster_moto_motor0_index], &motors[template_monster_moto_motor0_index]),
	FourWheelDrive(&vcms[template_velocity_controlled_motor_index], &vcms[template_velocity_controlled_motor_index], &vcms[template_velocity_controlled_motor_index], &vcms[template_velocity_controlled_motor_index])
};


void setup() {
	// Init LED pin
	pinMode(LED, OUTPUT);

	Wire.begin();
	i2cencoders[template_i2c_encoder1_index].init(MOTOR_393_TORQUE_ROTATIONS, MOTOR_393_TIME_DELTA);
	i2cencoders[template_i2c_encoder0_index].init(MOTOR_393_TORQUE_ROTATIONS, MOTOR_393_TIME_DELTA);
	i2cencoders[template_i2c_encoder1_index].setReversed(true);
	i2cencoders[template_i2c_encoder1_index].zero();
	i2cencoders[template_i2c_encoder0_index].zero();

	pinMode(template_button0_pin, INPUT_PULLUP);
	pinMode(template_button1_pin, INPUT);
	pinMode(template_button2_pin, INPUT);
	pinMode(template_button3_pin, INPUT_PULLUP);
	pinMode(template_limit_switch0_pin, INPUT_PULLUP);
	pinMode(template_limit_switch1_pin, INPUT);
	pinMode(template_limit_switch2_pin, INPUT);
	pinMode(template_limit_switch3_pin, INPUT_PULLUP);
	pinMode(template_switch0_pin, INPUT_PULLUP);
	pinMode(template_switch1_pin, INPUT);
	pinMode(template_switch2_pin, INPUT);
	pinMode(template_switch3_pin, INPUT_PULLUP);

	servos[template_servo_index].attach(template_servo_pin);

	pinMode(template_monster_moto_motor0_Apin, OUTPUT);
	pinMode(template_monster_moto_motor0_Bpin, OUTPUT);
	pinMode(template_monster_moto_motor0_PWMpin, OUTPUT);
	pinMode(template_monster_moto_motor1_Apin, OUTPUT);
	pinMode(template_monster_moto_motor1_Bpin, OUTPUT);
	pinMode(template_monster_moto_motor1_PWMpin, OUTPUT);
	pinMode(template_rover_five_motor0_Apin, OUTPUT);
	pinMode(template_rover_five_motor0_PWMpin, OUTPUT);
	pinMode(template_rover_five_motor1_Apin, OUTPUT);
	pinMode(template_rover_five_motor1_PWMpin, OUTPUT);
	pinMode(template_stepper_pinA, OUTPUT);
	pinMode(template_stepper_pinB, OUTPUT);
	pinMode(template_stepper_pinC, OUTPUT);
	pinMode(template_stepper_pinD, OUTPUT);
	steppers[template_stepper_index].setSpeed(9.000000);

	pinMode(template_encoder0_pinA, INPUT);
	pinMode(template_encoder0_pinB, INPUT);
	pinMode(template_encoder1_pinA, INPUT);
	pinMode(template_encoder1_pinB, INPUT);
	// Initialize Serial Communication
	Serial.begin(115200);

	// Attach callback methods
	attachCommandCallbacks();

	// Send the status to the PC that says the Arduino has booted
	// Note that this is a good debug function: it will let you also know
	// if your program had a bug and the arduino restarted
	cmdMessenger.sendBinCmd(kAcknowledge, kStart);

	// Flash led 3 times at the end of setup
	for(int i = 0; i < 3; i++) {
		digitalWrite(LED, HIGH);
		delay(250);
		digitalWrite(LED, LOW);
		delay(250);
	}
	ledState = LOW;
}
void loop() {
	// Process incoming serial data, and perform callbacks
	cmdMessenger.feedinSerialData();
	for(int i = 0; i < 1; i++) {
			vcms[i].runVPID();
		}
}
// Callbacks define on which received commands we take action
void attachCommandCallbacks() {
	// Attach callback methods
	cmdMessenger.attach(kI2CEncoderPosition,i2cEncoderPosition);
	cmdMessenger.attach(kI2CEncoderRawPosition,i2cEncoderRawPosition);
	cmdMessenger.attach(kI2CEncoderSpeed,i2cEncoderSpeed);
	cmdMessenger.attach(kI2CEncoderVelocity,i2cEncoderVelocity);
	cmdMessenger.attach(kI2CEncoderZero,i2cEncoderZero);
	cmdMessenger.attach(kReadSwitch, readSwitch);
	cmdMessenger.attach(kSetServo, setServo);
	cmdMessenger.attach(kDetachServo, detachServo);
	cmdMessenger.attach(kDriveMotor, driveMotor);
	cmdMessenger.attach(kStopMotor, stopMotor);
	cmdMessenger.attach(kSetStepperSpeed, setStepperSpeed);
	cmdMessenger.attach(kStepStepper, stepStepper);
	cmdMessenger.attach(kSetVCMVoltage, setVCMVoltage);
	cmdMessenger.attach(kSetVCMVelocity, setVCMVelocity);
	cmdMessenger.attach(kStopVCM, stopVCM);
	cmdMessenger.attach(kGetVCMVelocity, getVCMVelocity);
	cmdMessenger.attach(kGetVCMPosition, getVCMPosition);
	cmdMessenger.attach(kSetArm, setArm);
	cmdMessenger.attach(kDetachArm, detachArm);
	cmdMessenger.attach(kDriveFWD, driveFWD);
	cmdMessenger.attach(kStopFWD, stopFWD);
	cmdMessenger.attach(kDriveFWD_PID, driveFWD_PID);
	cmdMessenger.attach(kGetFWDLeftVelocity, getFWDLeftVelocity);
	cmdMessenger.attach(kGetFWDRightVelocity, getFWDRightVelocity);
	cmdMessenger.attach(kGetFWDLeftPosition, getFWDLeftPosition);
	cmdMessenger.attach(kGetFWDRightPosition, getFWDRightPosition);
	cmdMessenger.attach(kReadEncoder, readEncoder);
	cmdMessenger.attach(kZeroEncoder, zeroEncoder);
	cmdMessenger.attach(kReadDigitalLineSensor, readDigitalLineSensor);
	cmdMessenger.attach(kReadAnalogLineSensor, readAnalogLineSensor);
	cmdMessenger.attach(kReadUltrasonic, readUltrasonic);
	cmdMessenger.attach(kModifyPidConstants, modifyPidConstants);
	cmdMessenger.attach(kSetPidSetpoint, setPidSetpoint);
	cmdMessenger.attach(kPidOff, pidOff);
	cmdMessenger.attach(kPidDisplay, pidDisplay);
	cmdMessenger.attach(kModifyVpidConstants, modifyVpidConstants);
	cmdMessenger.attach(kSetVpidSetpoint, setVpidSetpoint);
	cmdMessenger.attach(kVpidOff, vpidOff);
	cmdMessenger.attach(kVpidDisplay, vpidDisplay);
}

// Called when a received command has no attached function
void OnUnknownCommand() {
	cmdMessenger.sendCmd(kError, kUnknown);
}

// Callback function that sets led on or off
void OnSetLed() {
	// Read led state argument, interpret string as boolean
	ledState = cmdMessenger.readBoolArg();
	digitalWrite(LED, ledState);
	cmdMessenger.sendBinCmd(kAcknowledge, ledState);
}

void i2cEncoderPosition() {
	if(cmdMessenger.available()) {
		int indexNum = cmdMessenger.readBinArg<int>();
		if(indexNum < 0 || indexNum > 2) {
			cmdMessenger.sendBinCmd(kError, kI2CEncoderPosition);
			return;
		}
		cmdMessenger.sendBinCmd(kAcknowledge, kI2CEncoderPosition);
		cmdMessenger.sendBinCmd(kResult, i2cencoders[indexNum].getPosition());
	} else {
		cmdMessenger.sendBinCmd(kError, kI2CEncoderPosition);
	}
}

void i2cEncoderRawPosition() {
	if(cmdMessenger.available()) {
		int indexNum = cmdMessenger.readBinArg<int>();
		if(indexNum < 0 || indexNum > 2) {
			cmdMessenger.sendBinCmd(kError, kI2CEncoderRawPosition);
			return;
		}
		cmdMessenger.sendBinCmd(kAcknowledge, kI2CEncoderRawPosition);
		cmdMessenger.sendBinCmd(kResult, i2cencoders[indexNum].getRawPosition());
	} else {
		cmdMessenger.sendBinCmd(kError, kI2CEncoderRawPosition);
	}
}

void i2cEncoderSpeed() {
	if(cmdMessenger.available()) {
		int indexNum = cmdMessenger.readBinArg<int>();
		if(indexNum < 0 || indexNum > 2) {
			cmdMessenger.sendBinCmd(kError, kI2CEncoderSpeed);
			return;
		}
		cmdMessenger.sendBinCmd(kAcknowledge, kI2CEncoderSpeed);
		cmdMessenger.sendBinCmd(kResult, i2cencoders[indexNum].getSpeed());
	} else {
		cmdMessenger.sendBinCmd(kError, kI2CEncoderSpeed);
	}
}

void i2cEncoderVelocity() {
	if(cmdMessenger.available()) {
		int indexNum = cmdMessenger.readBinArg<int>();
		if(indexNum < 0 || indexNum > 2) {
			cmdMessenger.sendBinCmd(kError, kI2CEncoderVelocity);
			return;
		}
		cmdMessenger.sendBinCmd(kAcknowledge, kI2CEncoderVelocity);
		cmdMessenger.sendBinCmd(kResult, i2cencoders[indexNum].getVelocity());
	} else {
		cmdMessenger.sendBinCmd(kError, kI2CEncoderVelocity);
	}
}

void i2cEncoderZero() {
	if(cmdMessenger.available()) {
		int indexNum = cmdMessenger.readBinArg<int>();
		if(indexNum < 0 || indexNum > 2) {
			cmdMessenger.sendBinCmd(kError, kI2CEncoderZero);
			return;
		}
		i2cencoders[indexNum].zero();
		cmdMessenger.sendBinCmd(kAcknowledge, kI2CEncoderZero);
	} else {
		cmdMessenger.sendBinCmd(kError, kI2CEncoderZero);
	}
}

void readSwitch() {
	if(cmdMessenger.available()) {
		int indexNum = cmdMessenger.readBinArg<int>();
		if(indexNum < 0 || indexNum > 12) {
			cmdMessenger.sendBinCmd(kError, kReadSwitch);
			return;
		}
			cmdMessenger.sendBinCmd(kAcknowledge, kReadSwitch);
			cmdMessenger.sendBinCmd(kResult, digitalRead(switches[indexNum]));
	} else {
		cmdMessenger.sendBinCmd(kError, kReadSwitch);
	}
}

void setServo() {
	if(cmdMessenger.available()) {
		int indexNum = cmdMessenger.readBinArg<int>();
		if(indexNum < 0 || indexNum > 1) {
			cmdMessenger.sendBinCmd(kError, kSetArm);
			return;
		}
		if(cmdMessenger.available()) {
			int value = cmdMessenger.readBinArg<int>();
			if(!servos[indexNum].attached()){
				servos[indexNum].attach(servo_pins[indexNum]);
			}
			servos[indexNum].write(value);
			cmdMessenger.sendBinCmd(kAcknowledge, kSetServo);
		} else {
			cmdMessenger.sendBinCmd(kError, kSetServo);
			return;
		}
	} else {
		cmdMessenger.sendBinCmd(kError, kSetArm);
	}
}

void detachServo() {
	if(cmdMessenger.available()) {
		int indexNum = cmdMessenger.readBinArg<int>();
		if(indexNum < 0 || indexNum > 1) {
			cmdMessenger.sendBinCmd(kError, kDetachServo);
			return;
		}
		servos[indexNum].detach();
		cmdMessenger.sendBinCmd(kAcknowledge, kDetachServo);
	} else {
		cmdMessenger.sendBinCmd(kError, kDetachServo);
	}
}

void driveMotor() {
	if(cmdMessenger.available()) {
		int indexNum = cmdMessenger.readBinArg<int>();
		if(indexNum < 0 || indexNum > 4) {
			cmdMessenger.sendBinCmd(kError, kDriveMotor);
			return;
		}
		if(cmdMessenger.available()) {
			int value = cmdMessenger.readBinArg<int>();
			if( value < -1023 || value > 1023) {
				motors[indexNum].drive(value);
				cmdMessenger.sendBinCmd(kAcknowledge, kDriveMotor);
			} else {
				cmdMessenger.sendBinCmd(kError, kDriveMotor);
			}
		} else {
			cmdMessenger.sendBinCmd(kError, kDriveMotor);
			return;
		}
	} else {
		cmdMessenger.sendBinCmd(kError, kDriveMotor);
	}
}

void stopMotor() {
	if(cmdMessenger.available()) {
		int indexNum = cmdMessenger.readBinArg<int>();
		if(indexNum < 0 || indexNum > 4) {
			cmdMessenger.sendBinCmd(kError, kStopMotor);
			return;
		}
		motors[indexNum].stop();
		cmdMessenger.sendBinCmd(kAcknowledge, kStopMotor);
	} else {
		cmdMessenger.sendBinCmd(kError, kStopMotor);
	}
}

void setStepperSpeed() {
	if(cmdMessenger.available()) {
		int indexNum = cmdMessenger.readBinArg<int>();
		if(indexNum < 0 || indexNum > 1) {
			cmdMessenger.sendBinCmd(kError, kSetStepperSpeed);
			return;
		}
		if(cmdMessenger.available()) {
			int value = cmdMessenger.readBinArg<int>();
			steppers[indexNum].setSpeed(value);
			cmdMessenger.sendBinCmd(kAcknowledge, kSetStepperSpeed);
		} else {
			cmdMessenger.sendBinCmd(kError, kSetStepperSpeed);
			return;
		}
	} else {
		cmdMessenger.sendBinCmd(kError, kSetStepperSpeed);
	}
}

void stepStepper() {
	if(cmdMessenger.available()) {
		int indexNum = cmdMessenger.readBinArg<int>();
		if(indexNum < 0 || indexNum > 1) {
			cmdMessenger.sendBinCmd(kError, kStepStepper);
			return;
		}
		if(cmdMessenger.available()) {
			int value = cmdMessenger.readBinArg<int>();
			steppers[indexNum].step(value);
			cmdMessenger.sendBinCmd(kAcknowledge, kStepStepper);
		} else {
			cmdMessenger.sendBinCmd(kError, kStepStepper);
			return;
		}
	} else {
		cmdMessenger.sendBinCmd(kError, kStepStepper);
	}
}

void setVCMVoltage() {
	if(cmdMessenger.available()) {
		int indexNum = cmdMessenger.readBinArg<int>();
		if(indexNum < 0 || indexNum > 1) {
			cmdMessenger.sendBinCmd(kError, kSetVCMVoltage);
			return;
		}
		if(cmdMessenger.available()) {
			int value = cmdMessenger.readBinArg<int>();
			if( value < -1023 || value > 1023) {
				vcms[indexNum].setValue(value);
				cmdMessenger.sendBinCmd(kAcknowledge, kSetVCMVoltage);
			} else {
				cmdMessenger.sendBinCmd(kError, kSetVCMVoltage);
			}
		} else {
			cmdMessenger.sendBinCmd(kError, kSetVCMVoltage);
			return;
		}
	} else {
		cmdMessenger.sendBinCmd(kError, kSetVCMVoltage);
	}
}

void setVCMVelocity() {
	if(cmdMessenger.available()) {
		int indexNum = cmdMessenger.readBinArg<int>();
		if(indexNum < 0 || indexNum > 1) {
			cmdMessenger.sendBinCmd(kError, kSetVCMVelocity);
			return;
		}
		if(cmdMessenger.available()) {
			float value = cmdMessenger.readBinArg<float>();
			vcms[indexNum].setVelocity(value);
			cmdMessenger.sendBinCmd(kAcknowledge, kSetVCMVelocity);
		} else {
			cmdMessenger.sendBinCmd(kError, kSetVCMVelocity);
			return;
		}
	} else {
		cmdMessenger.sendBinCmd(kError, kSetVCMVelocity);
	}
}

void stopVCM() {
	if(cmdMessenger.available()) {
		int indexNum = cmdMessenger.readBinArg<int>();
		if(indexNum < 0 || indexNum > 1) {
			cmdMessenger.sendBinCmd(kError, kStopVCM);
			return;
		}
		vcms[indexNum].stop();
		cmdMessenger.sendBinCmd(kAcknowledge, kStopVCM);
	} else {
		cmdMessenger.sendBinCmd(kError, kStopVCM);
	}
}

void getVCMVelocity() {
	if(cmdMessenger.available()) {
		int indexNum = cmdMessenger.readBinArg<int>();
		if(indexNum < 0 || indexNum > 1) {
			cmdMessenger.sendBinCmd(kError, kGetVCMVelocity);
			return;
		}
		cmdMessenger.sendBinCmd(kAcknowledge, kSetVCMVelocity);
		cmdMessenger.sendBinCmd(kResult, vcms[indexNum].getVelocity());
	} else {
		cmdMessenger.sendBinCmd(kError, kGetVCMVelocity);
	}
}

void getVCMPosition() {
	if(cmdMessenger.available()) {
		int indexNum = cmdMessenger.readBinArg<int>();
		if(indexNum < 0 || indexNum > 1) {
			cmdMessenger.sendBinCmd(kError, kGetVCMPosition);
			return;
		}
		cmdMessenger.sendBinCmd(kAcknowledge, kGetVCMPosition);
		cmdMessenger.sendBinCmd(kResult, vcms[indexNum].getPosition());
	} else {
		cmdMessenger.sendBinCmd(kError, kGetVCMPosition);
	}
}

void setArm() {
	if(cmdMessenger.available()) {
		int indexNum = cmdMessenger.readBinArg<int>();
		if(indexNum < 0 || indexNum > 1) {
			cmdMessenger.sendBinCmd(kError, kSetArm);
			return;
		}
		int pos[5];
		for(int i = 0; i < 5; i++) {
			if(cmdMessenger.available()) {
				pos[i] = cmdMessenger.readBinArg<int>();
			} else {
				cmdMessenger.sendBinCmd(kError, kSetArm);
				return;
			}
		}
		arms[indexNum].set(pos[0], pos[1], pos[2], pos[3], pos[4]);
		cmdMessenger.sendBinCmd(kAcknowledge, kSetArm);
	} else {
		cmdMessenger.sendBinCmd(kError, kSetArm);
	}
}

void detachArm() {
	if(cmdMessenger.available()) {
		int indexNum = cmdMessenger.readBinArg<int>();
		if(indexNum < 0 || indexNum > 1) {
			cmdMessenger.sendBinCmd(kError, kDetachArm);
			return;
		}
		arms[indexNum].detach();
		cmdMessenger.sendBinCmd(kAcknowledge, kDetachArm);
	} else {
		cmdMessenger.sendBinCmd(kError, kDetachArm);
	}
}

void driveFWD() {
	if(cmdMessenger.available()) {
		int indexNum = cmdMessenger.readBinArg<int>();
		if(indexNum < 0 || indexNum > 2) {
			cmdMessenger.sendBinCmd(kError, kDriveFWD);
			return;
		}
		int values[4];
		for(int i = 0; i < 4; i++) {
			if(cmdMessenger.available()) {
				values[i] = cmdMessenger.readBinArg<int>();
				if(values[i] < -1023 || values[i] > 1023) {
					cmdMessenger.sendBinCmd(kError, kDriveFWD);
					return;
				}
			} else {
				cmdMessenger.sendBinCmd(kError, kDriveFWD);
				return;
			}
		}
		fwds[indexNum].drive(values[0], values[1], values[2], values[3]);
		cmdMessenger.sendBinCmd(kAcknowledge, kDriveFWD);
	} else {
		cmdMessenger.sendBinCmd(kError, kDriveFWD);
	}
}

void stopFWD() {
	if(cmdMessenger.available()) {
		int indexNum = cmdMessenger.readBinArg<int>();
		if(indexNum < 0 || indexNum > 2) {
			cmdMessenger.sendBinCmd(kError, kStopFWD);
			return;
		}
		fwds[indexNum].stop();
		cmdMessenger.sendBinCmd(kAcknowledge, kStopFWD);
	} else {
		cmdMessenger.sendBinCmd(kError, kStopFWD);
	}
}

void driveFWD_PID() {
	if(cmdMessenger.available()) {
		int indexNum = cmdMessenger.readBinArg<int>();
		if(indexNum < 0 || indexNum > 2) {
			cmdMessenger.sendBinCmd(kError, kDriveFWD_PID);
			return;
		}
		float values[4];
		for(int i = 0; i < 4; i++) {
			if(cmdMessenger.available()) {
				values[i] = cmdMessenger.readBinArg<float>();
			} else {
				cmdMessenger.sendBinCmd(kError, kDriveFWD_PID);
				return;
			}
		}
		fwds[indexNum].drivePID(values[0], values[1], values[2], values[3]);
		cmdMessenger.sendBinCmd(kAcknowledge, kDriveFWD_PID);
	} else {
		cmdMessenger.sendBinCmd(kError, kDriveFWD_PID);
	}
}

void getFWDLeftVelocity() {
	if(cmdMessenger.available()) {
		int indexNum = cmdMessenger.readBinArg<int>();
		if(indexNum < 0 || indexNum > 2) {
			cmdMessenger.sendBinCmd(kError, kGetFWDLeftVelocity);
			return;
		}
		cmdMessenger.sendBinCmd(kAcknowledge, kGetFWDLeftVelocity);
		cmdMessenger.sendBinCmd(kResult, fwds[indexNum].getLeftVelocity());
	} else {
		cmdMessenger.sendBinCmd(kError, kGetFWDLeftVelocity);
	}
}

void getFWDRightVelocity() {
	if(cmdMessenger.available()) {
		int indexNum = cmdMessenger.readBinArg<int>();
		if(indexNum < 0 || indexNum > 2) {
			cmdMessenger.sendBinCmd(kError, kGetFWDRightVelocity);
			return;
		}
		cmdMessenger.sendBinCmd(kAcknowledge, kGetFWDRightVelocity);
		cmdMessenger.sendBinCmd(kResult, fwds[indexNum].getRightVelocity());
	} else {
		cmdMessenger.sendBinCmd(kError, kGetFWDRightVelocity);
	}
}

void getFWDLeftPosition() {
	if(cmdMessenger.available()) {
		int indexNum = cmdMessenger.readBinArg<int>();
		if(indexNum < 0 || indexNum > 2) {
			cmdMessenger.sendBinCmd(kError, kGetFWDLeftPosition);
			return;
		}
		cmdMessenger.sendBinCmd(kAcknowledge, kGetFWDLeftPosition);
		cmdMessenger.sendBinCmd(kResult, fwds[indexNum].getLeftPosition());
	} else {
		cmdMessenger.sendBinCmd(kError, kGetFWDLeftPosition);
	}
}

void getFWDRightPosition() {
	if(cmdMessenger.available()) {
		int indexNum = cmdMessenger.readBinArg<int>();
		if(indexNum < 0 || indexNum > 2) {
			cmdMessenger.sendBinCmd(kError, kGetFWDRightPosition);
			return;
		}
		cmdMessenger.sendBinCmd(kAcknowledge, kGetFWDRightPosition);
		cmdMessenger.sendBinCmd(kResult, fwds[indexNum].getRightPosition());
	} else {
		cmdMessenger.sendBinCmd(kError, kGetFWDRightPosition);
	}
}

void readEncoder() {
	if(cmdMessenger.available()) {
		int indexNum = cmdMessenger.readBinArg<int>();
		if(indexNum < 0 || indexNum > 2) {
			cmdMessenger.sendBinCmd(kError, kReadEncoder);
			return;
		}
		cmdMessenger.sendBinCmd(kAcknowledge, kReadEncoder);
		cmdMessenger.sendBinCmd(kResult, encoders[indexNum].read());
	} else {
		cmdMessenger.sendBinCmd(kError, kReadEncoder);
	}
}

void zeroEncoder() {
	if(cmdMessenger.available()) {
		int indexNum = cmdMessenger.readBinArg<int>();
		if(indexNum < 0 || indexNum > 2) {
			cmdMessenger.sendBinCmd(kError, kZeroEncoder);
			return;
		}
		encoders[indexNum].write(0);
		cmdMessenger.sendBinCmd(kAcknowledge, kZeroEncoder);
	} else {
		cmdMessenger.sendBinCmd(kError, kZeroEncoder);
	}
}

void readDigitalLineSensor() {
	if(cmdMessenger.available()) {
		int indexNum = cmdMessenger.readBinArg<int>();
		if(indexNum < 0 || indexNum > 1) {
			cmdMessenger.sendBinCmd(kError, kReadDigitalLineSensor);
			return;
		}
		cmdMessenger.sendBinCmd(kAcknowledge, kReadDigitalLineSensor);
		cmdMessenger.sendBinCmd(kResult, digitalRead(digital_linesensors[indexNum]));
	} else {
		cmdMessenger.sendBinCmd(kError, kReadDigitalLineSensor);
	}
}

void readAnalogLineSensor() {
	if(cmdMessenger.available()) {
		int indexNum = cmdMessenger.readBinArg<int>();
		if(indexNum < 0 || indexNum > 1) {
			cmdMessenger.sendBinCmd(kError, kReadAnalogLineSensor);
			return;
		}
		cmdMessenger.sendBinCmd(kAcknowledge, kReadAnalogLineSensor);
		cmdMessenger.sendBinCmd(kResult, analogRead(analog_linesensors[indexNum]));
	} else {
		cmdMessenger.sendBinCmd(kError, kReadAnalogLineSensor);
	}
}

void readUltrasonic() {
	if(cmdMessenger.available()) {
		int indexNum = cmdMessenger.readBinArg<int>();
		if(indexNum < 0 || indexNum > 1) {
			cmdMessenger.sendBinCmd(kError, kReadUltrasonic);
			return;
		}
		cmdMessenger.sendBinCmd(kAcknowledge, kReadUltrasonic);
		cmdMessenger.sendBinCmd(kResult, ultrasonics[indexNum].ping());
	} else {
		cmdMessenger.sendBinCmd(kError, kReadUltrasonic);
	}
}

void modifyPidConstants() {
	if(cmdMessenger.available()) {
		int indexNum = cmdMessenger.readBinArg<int>();
		if(indexNum < 0 || indexNum > 2) {
			cmdMessenger.sendBinCmd(kError, kModifyPidConstants);
			return;
		}
		float gains[3];
		for(int i = 0; i < 3; i++) {
			if(cmdMessenger.available()) {
				gains[i] = cmdMessenger.readBinArg<float>();
			} else {
				cmdMessenger.sendBinCmd(kError, kModifyPidConstants);
				return;
			}
		}
		pids[indexNum].SetTunings(gains[0], gains[1], gains[2]);
		cmdMessenger.sendBinCmd(kAcknowledge, kModifyPidConstants);
	} else {
		cmdMessenger.sendBinCmd(kError, kModifyPidConstants);
	}
}

void setPidSetpoint() {
	if(cmdMessenger.available()) {
		int indexNum = cmdMessenger.readBinArg<int>();
		if(indexNum < 0 || indexNum > 2) {
			cmdMessenger.sendBinCmd(kError, kSetPidSetpoint);
			return;
		}
		if(cmdMessenger.available()) {
			float value = cmdMessenger.readBinArg<float>();
			pids[indexNum].SetMode(AUTOMATIC);
			Setpoints_pid[indexNum] = value;
			cmdMessenger.sendBinCmd(kAcknowledge, kSetPidSetpoint);
		} else {
			cmdMessenger.sendBinCmd(kError, kSetPidSetpoint);
			return;
		}
	} else {
		cmdMessenger.sendBinCmd(kError, kSetPidSetpoint);
	}
}

void pidOff() {
	if(cmdMessenger.available()) {
		int indexNum = cmdMessenger.readBinArg<int>();
		if(indexNum < 0 || indexNum > 2) {
			cmdMessenger.sendBinCmd(kError, kPidOff);
			return;
		}
		pids[indexNum].SetMode(MANUAL);
		cmdMessenger.sendBinCmd(kAcknowledge, kPidOff);
	} else {
		cmdMessenger.sendBinCmd(kError, kPidOff);
	}
}

void pidDisplay() {
	if(cmdMessenger.available()) {
		int indexNum = cmdMessenger.readBinArg<int>();
		if(indexNum < 0 || indexNum > 2) {
			cmdMessenger.sendBinCmd(kError, kPidDisplay);
			return;
		}
		cmdMessenger.sendBinCmd(kAcknowledge, kPidDisplay);
		cmdMessenger.sendCmdStart(kResult);
		cmdMessenger.sendCmdBinArg(Inputs_pid[indexNum]);
		cmdMessenger.sendCmdBinArg(Setpoints_pid[indexNum]);
		cmdMessenger.sendCmdBinArg(Outputs_pid[indexNum]);
		cmdMessenger.sendCmdEnd();
	} else {
		cmdMessenger.sendBinCmd(kError, kPidDisplay);
	}
}

void modifyVpidConstants() {
	if(cmdMessenger.available()) {
		int indexNum = cmdMessenger.readBinArg<int>();
		if(indexNum < 0 || indexNum > 2) {
			cmdMessenger.sendBinCmd(kError, kModifyVpidConstants);
			return;
		}
		float gains[3];
		for(int i = 0; i < 3; i++) {
			if(cmdMessenger.available()) {
				gains[i] = cmdMessenger.readBinArg<float>();
			} else {
				cmdMessenger.sendBinCmd(kError, kModifyVpidConstants);
				return;
			}
		}
		vpids[indexNum].SetTunings(gains[0], gains[1], gains[2]);
		cmdMessenger.sendBinCmd(kAcknowledge, kModifyVpidConstants);
	} else {
		cmdMessenger.sendBinCmd(kError, kModifyVpidConstants);
	}
}

void setVpidSetpoint() {
	if(cmdMessenger.available()) {
		int indexNum = cmdMessenger.readBinArg<int>();
		if(indexNum < 0 || indexNum > 2) {
			cmdMessenger.sendBinCmd(kError, kSetVpidSetpoint);
			return;
		}
		if(cmdMessenger.available()) {
			float value = cmdMessenger.readBinArg<float>();
			vpids[indexNum].SetMode(AUTOMATIC);
			Setpoints_vpid[indexNum] = value;
			cmdMessenger.sendBinCmd(kAcknowledge, kSetVpidSetpoint);
		} else {
			cmdMessenger.sendBinCmd(kError, kSetVpidSetpoint);
		}
	} else {
		cmdMessenger.sendBinCmd(kError, kSetVpidSetpoint);
	}
}

void vpidOff() {
	if(cmdMessenger.available()) {
		int indexNum = cmdMessenger.readBinArg<int>();
		if(indexNum < 0 || indexNum > 2) {
			cmdMessenger.sendBinCmd(kError, kVpidOff);
			return;
		}
		pids[indexNum].SetMode(MANUAL);
		cmdMessenger.sendBinCmd(kAcknowledge, kVpidOff);
	} else {
		cmdMessenger.sendBinCmd(kError, kVpidOff);
	}
}

void vpidDisplay() {
	if(cmdMessenger.available()) {
		int indexNum = cmdMessenger.readBinArg<int>();
		if(indexNum < 0 || indexNum > 2) {
			cmdMessenger.sendBinCmd(kError, kVpidDisplay);
			return;
		}
		cmdMessenger.sendBinCmd(kAcknowledge, kVpidDisplay);
		cmdMessenger.sendCmdStart(kResult);
		cmdMessenger.sendCmdBinArg(Inputs_vpid[indexNum]);
		cmdMessenger.sendCmdBinArg(Setpoints_vpid[indexNum]);
		cmdMessenger.sendCmdBinArg(Outputs_vpid[indexNum]);
		cmdMessenger.sendCmdEnd();
	} else {
		cmdMessenger.sendBinCmd(kError, kVpidDisplay);
	}
}


